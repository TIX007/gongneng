<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>8×8 16:9 横向循环滚动 - Vue 3</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <style>
      :root {
        --gap: 8px; /* 卡片间距 */
        --radius: 10px; /* 卡片圆角 */
        --shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
      }

      * { box-sizing: border-box; }

      html, body {
        height: 100%;
        margin: 0;
        background: #0b0f1a;
        color: #e8ecf1;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
        overflow: hidden; /* 页面不出现滚动条 */
      }

      .page {
        display: flex;
        flex-direction: column;
        height: 100%;
        padding: 16px;
        gap: 12px;
      }

      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .title {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
        letter-spacing: 0.2px;
      }

      .controls {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        background: rgba(255, 255, 255, 0.06);
        padding: 8px 12px;
        border-radius: 999px;
        backdrop-filter: blur(6px);
      }

      .controls input[type="range"] {
        width: 160px;
        accent-color: #5dd4ff;
      }

      .hint { opacity: 0.8; font-size: 12px; }

      .gallery {
        flex: 1;
        display: grid;
        grid-template-rows: repeat(8, 1fr); /* 8 行 */
        gap: 10px; /* 行间距 */
        min-height: 0; /* 防止子项溢出时拉伸 */
      }

      .row {
        position: relative;
        overflow: hidden;
        width: 100%;
        height: min(14vh, 12.5vw * 9 / 16 + var(--gap)); /* 依据 8 列宽的 16:9 高度估算行高 */
        border-radius: 14px;
        background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
        outline: 1px solid rgba(255, 255, 255, 0.06);
      }

      .track {
        display: flex;
        align-items: center;
        gap: var(--gap);
        padding: 8px;
        will-change: transform;
        animation-timing-function: linear;
        animation-iteration-count: infinite;
        animation-duration: var(--duration, 18s);
      }

      /* 奇数行（1、3、5、7）：从左向右滚动 */
      .row[data-dir="ltr"] .track { animation-name: scroll-ltr; }
      /* 偶数行（2、4、6、8）：从右向左滚动 */
      .row[data-dir="rtl"] .track { animation-name: scroll-rtl; }

      @keyframes scroll-rtl {
        from { transform: translateX(0%); }
        to { transform: translateX(-50%); }
      }

      @keyframes scroll-ltr {
        from { transform: translateX(-50%); }
        to { transform: translateX(0%); }
      }

      .card {
        flex: 0 0 calc(100% / 8 - var(--gap)); /* 8 列 */
        aspect-ratio: 16 / 9; /* 16:9 比例 */
        border-radius: var(--radius);
        overflow: hidden;
        box-shadow: var(--shadow);
        background: #0e131f;
      }

      .card img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
        transition: transform 0.4s ease;
      }

      .card:hover img { transform: scale(1.05); }

      /* 悬停暂停该行 */
      .row:hover .track { animation-play-state: paused; }

      /* 拖拽/激活时暂停动画与过渡 */
      .row.row--active .track { animation-play-state: paused; }
      .row .card { transition: transform 0.2s ease; cursor: grab; }
      .row.row--active .card:hover img { transform: none; }

      /* 减少动态（系统设置）支持 */
      @media (prefers-reduced-motion: reduce) {
        .track { animation: none !important; }
      }
    </style>
  </head>
  <body>
    <div id="app" class="page">
      <div class="header">
        <h1 class="title">8×8 16:9 图片墙 · 横向循环滚动</h1>
        <div class="controls">
          <span>速度倍率</span>
          <input type="range" min="0.5" max="3" step="0.1" v-model.number="speedMultiplier" />
          <span class="hint">{{ speedMultiplier.toFixed(1) }}×</span>
        </div>
      </div>
      <div class="gallery">
        <!-- 8 行：奇数行从左向右，偶数行从右向左 -->
        <div
          v-for="(row, rowIdx) in rows"
          :key="rowIdx"
          class="row"
          :data-dir="row.dir"
          :class="{ 'row--active': row.drag.active }"
          :style="{ '--duration': row.duration + 's' }"
          :ref="el => setRowRef(rowIdx, el)"
        >
          <div class="track">
            <!-- 8 张 + 8 张克隆，实现无缝循环（总宽 ~ 200%） -->
            <div
              v-for="(src, idx) in row.doubleImages"
              :key="idx"
              class="card"
              :style="getDragStyle(rowIdx, idx)"
              @pointerdown="onPointerDown(rowIdx, idx, $event)"
            >
              <img :src="src" :alt="`row-${rowIdx}-img-${idx % row.images.length}`" loading="lazy" />
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const { createApp, ref, computed, watch, onBeforeUnmount } = Vue;

      createApp({
        setup() {
          const numRows = 8;      // 行数
          const perRow = 8;       // 每行图片数
          const baseSeconds = 18; // 基础动画时长（移动 50% 宽度）
          const speedMultiplier = ref(1);

          // 带交互状态的行数据
          const rows = ref(Array.from({ length: numRows }, (_, rowIndex) => {
            const images = Array.from({ length: perRow }, (_, i) => {
              const seed = rowIndex * 1000 + i; // 稳定 seed
              return `https://picsum.photos/seed/${seed}/640/360`;
            });
            const dir = rowIndex % 2 === 0 ? 'ltr' : 'rtl';
            return {
              images,
              doubleImages: images.concat(images),
              dir,
              duration: baseSeconds,
              drag: {
                active: false,
                pointerId: null,
                anchorIdx: null,
                originX: 0,
                originY: 0,
                currentX: 0,
                currentY: 0,
                deltaX: 0,
                deltaY: 0,
                radiusPx: 0,
                effectsByIndex: [],
              },
            };
          }));

          // 存 row 容器引用，便于测量子卡片位置
          const rowEls = ref([]);
          function setRowRef(rowIdx, el) {
            rowEls.value[rowIdx] = el;
          }

          // 根据速度倍率更新每行动画时长
          watch(speedMultiplier, (val) => {
            rows.value.forEach((row, rowIndex) => {
              const rowOffset = (rowIndex % 4) * 1.25;
              row.duration = Math.max(8, (baseSeconds + rowOffset) / val);
            });
          }, { immediate: true });

          // 计算并缓存某行每张卡片的 transform
          const repelMaxPx = 60; // 最大排斥位移
          const centerScaleMax = 0.25; // 中心最大放大
          function computeEffectsForRow(rowIdx) {
            const row = rows.value[rowIdx];
            if (!row.drag.active) return;

            const rowEl = rowEls.value[rowIdx];
            if (!rowEl) return;

            const cards = rowEl.querySelectorAll('.card');
            const effects = new Array(cards.length);
            const pointerX = row.drag.currentX;
            const pointerY = row.drag.currentY;
            const radius = Math.max(8, row.drag.radiusPx);

            for (let i = 0; i < cards.length; i++) {
              const rect = cards[i].getBoundingClientRect();
              const cx = rect.left + rect.width / 2;
              const cy = rect.top + rect.height / 2;

              const dx = cx - pointerX;
              const dy = cy - pointerY;
              const dist = Math.hypot(dx, dy);

              let translateX = 0;
              let translateY = 0;
              let scale = 1;
              let zIndex = 1;

              if (dist <= radius) {
                const t = 1 - dist / radius; // [0,1]
                const ease = Math.pow(t, 0.8);
                const normX = dx / (dist || 1);
                const normY = dy / (dist || 1);
                translateX = normX * repelMaxPx * ease;
                translateY = normY * repelMaxPx * ease;
                scale = 1 + centerScaleMax * ease;
                zIndex = 10;
              }

              if (i === row.drag.anchorIdx) {
                // 被拖拽卡片叠加拖拽偏移与更高层级
                translateX += row.drag.deltaX;
                translateY += row.drag.deltaY;
                scale += 0.05;
                zIndex = 30;
              }

              effects[i] = { transform: `translateX(${translateX}px) translateY(${translateY}px) scale(${scale})`, zIndex };
            }

            row.drag.effectsByIndex = effects;
          }

          // 指针事件
          let boundMove = null;
          let boundUp = null;
          function onPointerDown(rowIdx, trackIdx, e) {
            e.preventDefault();
            const row = rows.value[rowIdx];
            row.drag.active = true;
            row.drag.pointerId = e.pointerId;
            row.drag.anchorIdx = trackIdx;
            row.drag.originX = e.clientX;
            row.drag.originY = e.clientY;
            row.drag.currentX = e.clientX;
            row.drag.currentY = e.clientY;
            row.drag.deltaX = 0;
            row.drag.deltaY = 0;

            const cardRect = e.currentTarget.getBoundingClientRect();
            row.drag.radiusPx = cardRect.width * 3; // 半径=3个卡片宽度

            computeEffectsForRow(rowIdx);

            boundMove = (evt) => {
              if (!row.drag.active) return;
              row.drag.currentX = evt.clientX;
              row.drag.currentY = evt.clientY;
              row.drag.deltaX = evt.clientX - row.drag.originX;
              row.drag.deltaY = evt.clientY - row.drag.originY;
              computeEffectsForRow(rowIdx);
            };
            boundUp = () => {
              // 结束拖拽与复位
              row.drag.active = false;
              row.drag.pointerId = null;
              row.drag.anchorIdx = null;
              row.drag.effectsByIndex = [];
              row.drag.deltaX = 0;
              row.drag.deltaY = 0;
              window.removeEventListener('pointermove', boundMove);
              window.removeEventListener('pointerup', boundUp);
              window.removeEventListener('pointercancel', boundUp);
            };

            window.addEventListener('pointermove', boundMove, { passive: true });
            window.addEventListener('pointerup', boundUp, { passive: true });
            window.addEventListener('pointercancel', boundUp, { passive: true });
          }

          function getDragStyle(rowIdx, trackIdx) {
            const row = rows.value[rowIdx];
            if (!row.drag.active || !row.drag.effectsByIndex) return null;
            return row.drag.effectsByIndex[trackIdx] || null;
          }

          onBeforeUnmount(() => {
            if (boundMove) window.removeEventListener('pointermove', boundMove);
            if (boundUp) window.removeEventListener('pointerup', boundUp);
            if (boundUp) window.removeEventListener('pointercancel', boundUp);
          });

          return { rows, speedMultiplier, setRowRef, onPointerDown, getDragStyle };
        },
      }).mount('#app');
    </script>
  </body>
  </html>


